################################################
#                 WARNING!                     #
# This file has been auto-generated by xdress. #
# Do not modify!!!                             #
#                                              #
#                                              #
#                    Come on, guys. I mean it! #
################################################
"""
"""
cimport dtypes
cimport numpy as np
from libc.stdlib cimport free
from libcpp cimport bool as cpp_bool
from libcpp.string cimport string as std_string
from libcpp.vector cimport vector as cpp_vector

import numpy as np

np.import_array()



cdef class AliasTable:
    """
    
    Attributes
    ----------
    prob (std::vector< double >) :
    alias (std::vector< int >) :
    n (int) :
    
    
    Methods
    -------
    AliasTable
    ~AliasTable
    sample_pdf
    
    Notes
    -----
    This class was defined in source_sampling.h
    
    The class is found in the "" namespace"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults


    def __init__(self, p):
        """AliasTable(self, p)
        
        
        Parameters
        ----------
        p : vect_d
        
        Returns
        -------
        None
        
        """
        cdef cpp_vector[double] p_proxy
        cdef int ip
        cdef int p_size
        cdef double * p_data
        # p is a ('vector', 'float64', 0)
        p_size = len(p)
        if isinstance(p, np.ndarray) and (<np.ndarray> p).descr.type_num == np.NPY_FLOAT64:
            p_data = <double *> np.PyArray_DATA(<np.ndarray> p)
            p_proxy = cpp_vector[double](<size_t> p_size)
            for ip in range(p_size):
                p_proxy[ip] = p_data[ip]
        else:
            p_proxy = cpp_vector[double](<size_t> p_size)
            for ip in range(p_size):
                p_proxy[ip] = <double> p[ip]
        self._inst = new cpp_source_sampling.AliasTable(p_proxy)
    
    
    def __dealloc__(self):
        if self._free_inst and self._inst is not NULL:
            free(self._inst)

    # attributes

    # methods
    def sample_pdf(self, rand1, rand2):
        """sample_pdf(self, rand1, rand2)
        
        
        Parameters
        ----------
        ran1 : double
        
        ran2 : double
        
        Returns
        -------
        res1 : int
        
        """
        cdef int rtnval
        rtnval = (<cpp_source_sampling.AliasTable *> self._inst).sample_pdf(<double> rand1, <double> rand2)
        return int(rtnval)
    
    
    

    pass





cdef class Sampler:
    """
    
    Attributes
    ----------
    _e_bounds (vect_d) :
    _mode (Mode) :
    _mesh (MBInterface *) :
    _filename (str) :
    _src_tag_name (str) :
    _bias_tag_name (str) :
    _num_e_groups (int) :
    _num_bias_groups (int) :
    _num_ves (int) :
    _ve_type (MBEntityType) :
    _verts_per_ve (int) :
    _all_edge_points (std::vector< ) :
    _at (None) :
    _biased_weights (std::vector< double >) :
    
    
    Methods
    -------
    Sampler
    ~Sampler
    get_bias_pdf
    get_e
    get_mesh_geom_data
    get_mesh_tag_data
    get_num_groups
    get_w
    get_xyz
    normalize_pdf
    particle_birth
    setup
    
    Notes
    -----
    This class was defined in source_sampling.h
    
    The class is found in the "" namespace"""



    # constuctors
    def __cinit__(self, *args, **kwargs):
        self._inst = NULL
        self._free_inst = True

        # cached property defaults


    def _sampler_sampler_0(self, filename, src_tag_name, e_bounds, bias_tag_name):
        """Sampler(self, filename, src_tag_name, e_bounds, bias_tag_name)
         This method was overloaded in the C-based source. To overcome
        this we ill put the relevant docstring for each version below.
        Each version will begin with a line of # characters.
        
        
        
        Parameters
        ----------
        e_bounds : vect_d
        
        src_tag_name : str
        
        bias_tag_name : str
        
        filename : str
        
        Returns
        -------
        None
        
        ################################################################
        
        
        
        Parameters
        ----------
        e_bounds : vect_d
        
        src_tag_name : str
        
        uniform : bool
        
        filename : str
        
        Returns
        -------
        None
        
        """
        cdef char * filename_proxy
        cdef char * src_tag_name_proxy
        cdef cpp_vector[double] e_bounds_proxy
        cdef int ie_bounds
        cdef int e_bounds_size
        cdef double * e_bounds_data
        cdef char * bias_tag_name_proxy
        filename_bytes = filename.encode()
        src_tag_name_bytes = src_tag_name.encode()
        # e_bounds is a ('vector', 'float64', 0)
        e_bounds_size = len(e_bounds)
        if isinstance(e_bounds, np.ndarray) and (<np.ndarray> e_bounds).descr.type_num == np.NPY_FLOAT64:
            e_bounds_data = <double *> np.PyArray_DATA(<np.ndarray> e_bounds)
            e_bounds_proxy = cpp_vector[double](<size_t> e_bounds_size)
            for ie_bounds in range(e_bounds_size):
                e_bounds_proxy[ie_bounds] = e_bounds_data[ie_bounds]
        else:
            e_bounds_proxy = cpp_vector[double](<size_t> e_bounds_size)
            for ie_bounds in range(e_bounds_size):
                e_bounds_proxy[ie_bounds] = <double> e_bounds[ie_bounds]
        bias_tag_name_bytes = bias_tag_name.encode()
        self._inst = new cpp_source_sampling.Sampler(std_string(<char *> filename_bytes), std_string(<char *> src_tag_name_bytes), e_bounds_proxy, std_string(<char *> bias_tag_name_bytes))
    
    
    def _sampler_sampler_1(self, filename, src_tag_name, e_bounds, uniform):
        """Sampler(self, filename, src_tag_name, e_bounds, uniform)
         This method was overloaded in the C-based source. To overcome
        this we ill put the relevant docstring for each version below.
        Each version will begin with a line of # characters.
        
        
        
        Parameters
        ----------
        e_bounds : vect_d
        
        src_tag_name : str
        
        bias_tag_name : str
        
        filename : str
        
        Returns
        -------
        None
        
        ################################################################
        
        
        
        Parameters
        ----------
        e_bounds : vect_d
        
        src_tag_name : str
        
        uniform : bool
        
        filename : str
        
        Returns
        -------
        None
        
        """
        cdef char * filename_proxy
        cdef char * src_tag_name_proxy
        cdef cpp_vector[double] e_bounds_proxy
        cdef int ie_bounds
        cdef int e_bounds_size
        cdef double * e_bounds_data
        filename_bytes = filename.encode()
        src_tag_name_bytes = src_tag_name.encode()
        # e_bounds is a ('vector', 'float64', 0)
        e_bounds_size = len(e_bounds)
        if isinstance(e_bounds, np.ndarray) and (<np.ndarray> e_bounds).descr.type_num == np.NPY_FLOAT64:
            e_bounds_data = <double *> np.PyArray_DATA(<np.ndarray> e_bounds)
            e_bounds_proxy = cpp_vector[double](<size_t> e_bounds_size)
            for ie_bounds in range(e_bounds_size):
                e_bounds_proxy[ie_bounds] = e_bounds_data[ie_bounds]
        else:
            e_bounds_proxy = cpp_vector[double](<size_t> e_bounds_size)
            for ie_bounds in range(e_bounds_size):
                e_bounds_proxy[ie_bounds] = <double> e_bounds[ie_bounds]
        self._inst = new cpp_source_sampling.Sampler(std_string(<char *> filename_bytes), std_string(<char *> src_tag_name_bytes), e_bounds_proxy, <bint> uniform)
    
    
    _sampler_sampler_0_argtypes = frozenset(((0, str), (1, str), (2, np.ndarray), (3, str), ("filename", str), ("src_tag_name", str), ("e_bounds", np.ndarray), ("bias_tag_name", str)))
    _sampler_sampler_1_argtypes = frozenset(((0, str), (1, str), (2, np.ndarray), (3, bool), ("filename", str), ("src_tag_name", str), ("e_bounds", np.ndarray), ("uniform", bool)))
    
    def __init__(self, *args, **kwargs):
        """Sampler(self, filename, src_tag_name, e_bounds, uniform)
         This method was overloaded in the C-based source. To overcome
        this we ill put the relevant docstring for each version below.
        Each version will begin with a line of # characters.
        
        
        
        Parameters
        ----------
        e_bounds : vect_d
        
        src_tag_name : str
        
        bias_tag_name : str
        
        filename : str
        
        Returns
        -------
        None
        
        ################################################################
        
        
        
        Parameters
        ----------
        e_bounds : vect_d
        
        src_tag_name : str
        
        uniform : bool
        
        filename : str
        
        Returns
        -------
        None
        
        """
        types = set([(i, type(a)) for i, a in enumerate(args)])
        types.update([(k, type(v)) for k, v in kwargs.items()])
        # vtable-like dispatch for exactly matching types
        if types <= self._sampler_sampler_0_argtypes:
            self._sampler_sampler_0(*args, **kwargs)
            return
        if types <= self._sampler_sampler_1_argtypes:
            self._sampler_sampler_1(*args, **kwargs)
            return
        # duck-typed dispatch based on whatever works!
        try:
            self._sampler_sampler_0(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        try:
            self._sampler_sampler_1(*args, **kwargs)
            return
        except (RuntimeError, TypeError, NameError):
            pass
        raise RuntimeError('method __init__() could not be dispatched')
    
    def __dealloc__(self):
        if self._free_inst and self._inst is not NULL:
            free(self._inst)

    # attributes

    # methods
    def particle_birth(self, rands):
        """particle_birth(self, rands)
        
        
        Parameters
        ----------
        rands : vect_d
        
        Returns
        -------
        res1 : vect_d
        
        """
        cdef cpp_vector[double] rands_proxy
        cdef int irands
        cdef int rands_size
        cdef double * rands_data
        cdef cpp_vector[double] rtnval
        
        cdef np.npy_intp rtnval_proxy_shape[1]
        # rands is a ('vector', 'float64', 0)
        rands_size = len(rands)
        if isinstance(rands, np.ndarray) and (<np.ndarray> rands).descr.type_num == np.NPY_FLOAT64:
            rands_data = <double *> np.PyArray_DATA(<np.ndarray> rands)
            rands_proxy = cpp_vector[double](<size_t> rands_size)
            for irands in range(rands_size):
                rands_proxy[irands] = rands_data[irands]
        else:
            rands_proxy = cpp_vector[double](<size_t> rands_size)
            for irands in range(rands_size):
                rands_proxy[irands] = <double> rands[irands]
        rtnval = (<cpp_source_sampling.Sampler *> self._inst).particle_birth(rands_proxy)
        rtnval_proxy_shape[0] = <np.npy_intp> rtnval.size()
        rtnval_proxy = np.PyArray_SimpleNewFromData(1, rtnval_proxy_shape, np.NPY_FLOAT64, &rtnval[0])
        rtnval_proxy = np.PyArray_Copy(rtnval_proxy)
        return rtnval_proxy
    
    
    

    pass






{'cpppxd_footer': '', 'pyx_header': '', 'pxd_header': '', 'pxd_footer': '', 'cpppxd_header': '', 'pyx_footer': ''}
